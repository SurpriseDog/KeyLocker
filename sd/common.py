#!/usr/bin/python3
# An autogenerated selection of SurpriseDog's common functions relevant to this project.
# To see how this file was created visit: https://github.com/SurpriseDog/Star-Wrangler

import os
import re
import sys
import time
import math
import queue
import random
import secrets
import datetime
import itertools
import threading


def chunker(lis, lines=2, overlap=False):
	'''Take a list a return its values n items at a time
	alternate way: zip(*[iter(lis)]*n)'''
	if len(lis) <= lines:
		yield lis
	else:
		step = 1 if overlap else lines
		for start in range(0, len(lis) - lines + 1, step):
			yield lis[start:start + lines]


def percent(num, digits=0):
	if not digits:
		return str(int(num * 100)) + '%'
	else:
		return sig(num * 100, digits) + '%'


def roundint(num, mod):
	"Round an integer to the nearest modulus"
	ret = num // mod * mod
	remainder = num % mod
	if remainder < mod // 2:
		return ret
	else:
		return ret + mod


def plural(val, word, multiple=None):
	'''Return value + word with plural ending
	You give plural the multiple version of the word to use or let it try to figure it out.
	https://www.grammarly.com/blog/plural-nouns/
	'''

	def get_word(word):
		word = word.lower()
		vowels = 'aoeiu'

		# Exceptions that have irregular changes
		exceptions = dict(
			child='children',
			goose='geese',
			man='men',
			woman='women',
			tooth='teeth',
			foot='feet',
			mouse='mice',
			person='people',
			dice='dies')
		if word in exceptions:
			return exceptions[word]

		# Game words that don't change ending
		if word in (
				'bison',
				'buffalo',
				'carp',
				'cod',
				'deer',
				'fish',
				'kakapo',
				'neat',
				'pike',
				'salmon',
				'sheep',
				'shrimp',
				'shrimps',
				'squid',
				'trout'):
			return word

		for ending in ('f', 'fe'):
			if word.endswith(ending):
				return word[:-1] + 'ves'

		if word.endswith('us') and len(word) > 4:
			return word[:-2] + 'i'

		if word.endswith('o'):
			if word not in ('photo', 'piano', 'halo'):
				return word + 'es'

		if word.endswith('is'):
			return word[:-2] + 'es'

		if word.endswith('on'):
			return word[:-2] + 'a'

		if word.endswith('y') and word[-2] not in vowels:
			return word[:-1] + 'ies'

		for ending in ('s', 'ss', 'sh', 'ch', 'x', 'z'):
			if word.endswith(ending):
				return word + 'es'

		return word + 's'

	if val == 1:
		return str(val) + ' ' + word
	elif multiple:
		return str(val) + ' ' + multiple
	else:
		replacement = get_word(word)
		if word.title() == word:
			replacement = replacement.title()
		if word.upper() == word:
			replacement = replacement.upper()

		return str(val) + ' ' + replacement


def randexp(low, high=None):
	'''
	Returns a random number within an exponential range between 2**low and 2**high minus 1 to include zero.
	Useful for function testing
	'''
	if not high:
		high = low
		low = 0
	exp = randint(low, high-1)
	return random.uniform(2**exp, 2**(exp+1)) - 1


def rns(num):
	"readble number size"
	if num < 1e16:
		return rfs(num, order=' KMBT', suffix='', space='')
	else:
		return num


def map_nested(func, array):
	"Apply a function to a nested array and return it"
	out = []
	for item in array:
		if type(item) not in (tuple, list):
			out.append(func(item))
		else:
			out.append(map_nested(func, item))
	return out


class DotDict(dict):
	'''
	Example:
	m = dotdict({'first_name': 'Eduardo'}, last_name='Pool', age=24, sports=['Soccer'])

	Modified from:
	https://stackoverflow.com/questions/2352181/how-to-use-a-dot-to-access-members-of-dictionary
	to set unlimited chained .variables like DotDict().tom.bob = 3
	'''

	def __init__(self, *args, **kwargs):
		super(DotDict, self).__init__(*args, **kwargs)
		for arg in args:
			if isinstance(arg, dict):
				for k, v in arg.items():
					self[k] = v

		if kwargs:
			for k, v in kwargs.items():
				self[k] = v

	def __getattr__(self, attr):
		if attr in self:
			return self.get(attr)
		else:
			self[attr] = DotDict()
			return self[attr]

	def __setattr__(self, key, value):
		self.__setitem__(key, value)

	def __contains__(self, key):
		return bool(key in self.__dict__)

	def __setitem__(self, key, value):
		super(DotDict, self).__setitem__(key, value)
		self.__dict__.update({key: value})

	def __delattr__(self, item):
		self.__delitem__(item)

	def __delitem__(self, key):
		super(DotDict, self).__delitem__(key)
		del self.__dict__[key]


def spawn(func, *args, daemon=True, delay=0, **kargs):
	'''Spawn a function to run seperately and return the que
	waits for delay seconds before running
	Get the results with que.get()
	daemon = running in background, will shutdown automatically when main thread exits
	Check if the thread is still running with thread.is_alive()
	print('func=', func, id(func))'''
	#replaces fork_cmd, mcall

	def worker():
		if delay:
			time.sleep(delay)
		ret = func(*args, **kargs)
		que.put(ret)

	que = queue.Queue()
	# print('args=', args)
	thread = threading.Thread(target=worker)
	thread.daemon = daemon
	thread.start()
	return que, thread


def doter(condition, wait=1, header='', exp=1.02, limit=600):
	'''
	Print dots while condition is True,
	The time between dots slows for every dot produced acconding to exponent exp
	limit = the max sleep time, 0 to disable
	'''
	if condition():
		print(header, end='...', flush=True)
	else:
		return
	for num in itertools.count():
		sleep_t = wait * exp ** num		#https://www.desmos.com/calculator/c0ozuvcm6s
		if limit and sleep_t > limit:
			sleep_t = limit
		time.sleep(sleep_t)
		if not condition():
			break
		print('.', end='', flush=True)
	print()


def list_get(lis, index, default=''):

	# Fetch a value from a list if it exists, otherwise return default
	# Now accepts negative indexes
	length = len(lis)
	if -length <= index < length:
		return lis[index]
	else:
		return default


def fmt_clock(num, smallest=None):
	'''
	Format in 9:12 format
	smallest    = smallest units for non pretty printing
	'''
	# Normal "2:40" style format
	num = int(num)
	s = str(datetime.timedelta(seconds=num))
	if num < 3600:
		s = s[2:]  # .lstrip('0')

	# Strip smaller units
	if smallest == 'minutes' or (not smallest and num >= 3600):
		return s[:-3]
	elif smallest == 'hours':
		return s[:-6] + ' hours'
	else:
		return s


def fmt_time(num, digits=2, pretty=True, smallest=None, fields=None, zeroes='skip', **kargs):
	'''Return a neatly formated time string.
	sig         = the number of significant digits.
	fields      = Instead of siginificant digits, specify the number of date fields to produce.
	fields overrides digits
	zeroes		= Show fields with zeroes or skip to the next field
	todo make fields the default?
	'''
	if num < 0:
		num *= -1
		return '-' + fmt_time(**locals())
	if not pretty:
		return fmt_clock(num, smallest)

	if fields:
		digits = 0
		fr = fields		#fields remaining
	elif 'sig' in kargs:
		fr = 0
		digits = kargs['sig']
		print("\nWarning! sig is deprecated. Use <digits> instead.\n")

	# Return number and unit text
	if num < 5.391e-44:
		return "0 seconds"
	out = []
	# For calculations involving leap years, use the datetime library:
	limits = (5.391e-44, 1e-24, 1e-21, 1e-18, 1e-15, 1e-12, 1e-09, 1e-06, 0.001, 1, 60,
			  3600, 3600 * 24, 3600 * 24 * 7, 3600 * 24 * 30.4167, 3600 * 24 * 365.2422)
	names = (
		'Planck time',
		'yoctosecond',
		'zeptosecond',
		'attosecond',
		'femtosecond',
		'picosecond',
		'nanosecond',
		'microsecond',
		'millisecond',
		'second',
		'minute',
		'hour',
		'day',
		'week',
		'month',
		'year')

	index = bisect_small(limits, num) + 1
	while index > 0:
		index -= 1
		unit = limits[index]		#
		u_num = num / unit          # unit number for current name
		name = names[index]			# Unit name like weeks

		if name == 'week' and u_num < 2:
			# Replace weeks with days when less than 2 weeks
			digits -= 1
			continue

		#In fields modes, just keep outputting fields until fr is exhausted
		if fields:
			fr -= 1
			u_num = int(u_num)
			if u_num == 0 and zeroes == 'skip':
				continue
			out += [str(u_num) + ' ' + name + ('s' if u_num != 1 else '')]
			num -= u_num * unit
			if fr == 0:
				break
			continue


		# Avoids the "3 minutes, 2 nanoseconds" nonsense.
		if u_num < 1 and zeroes == 'skip':
			if name in ('second', 'minute', 'hour', 'week', 'month'):
				digits -= 2
			else:
				digits -= 3
			continue

		#In digits mode, output fields containing significant digits until seconds are reached, then stop
		if num >= 60:     # Minutes or higher
			u_num = int(u_num)
			out += [str(u_num) + ' ' + name + ('s' if u_num != 1 else '')]
			digits -= len(str(u_num))
			num -= u_num * unit
			if digits <= 0:
				break
		else:
			# If time is less than a minute, just output last field and quit
			d = digits if digits >= 1 else 1
			out += [sig(u_num, d) + ' ' + name + ('s' if u_num != 1 else '')]
			break

	return ', '.join(out)


def walk(path, match=None, **kargs):
	'''Walk through directory looking for full filenames
	optional match applies a re.match expression to base filename'''

	for (dirpath, _dirnames, filenames) in os.walk(path, **kargs):
		for filename in filenames:
			if match and re.match(match, filename) or not match:
				yield os.path.join(dirpath, filename)


def chunk_up(num, chunk=64):
	"Return a multiple of chunk >= num"
	return ((num - 1) // chunk + 1) * chunk


def error(*args, header='\nError:', err=RuntimeError, **kargs):
	eprint(*args, header=header, v=3, **kargs)
	raise err


def sround(num, digits=3):
	"Round a number (with trailing 0s) for printing"
	return ('{0:.' + str(digits) + 'f}').format(num)


def randint(start, stop):
	"Better than random.randint"
	size = int(stop + 1 - start)
	return secrets.randbelow(size) + int(start)


def query(*question, confirmation='', negation=''):
	'''Ask the user a question. They can type y Y yes Yes and so on.
	Return True if yes, False if No
	If confirmation is passed, then the user must type the same word as confirmation to return True
	If negation is passed user can type the negation word to return False'''

	if not question:
		question = ("Continue?",)
	msg = ' '.join(question)

	while True:
		response = input(msg + ' ')
		response = response.strip().lower()
		if not response:
			continue

		# Have user confirm
		if response and confirmation:
			if response == confirmation.strip().lower():
				return True
			if negation:
				if response == negation.strip().lower():
					return False
				else:
					continue
			else:
				return False

		# Convert response to a single letter y or n
		if response:
			response = response[0]
			if response == 'y':
				return True
			elif response == 'n':
				return False


def mrfs(*args):
	"rfs for memory sizes"
	return rfs(*args, mult=1024, order=[' ', 'Ki', 'Mi', 'Gi', 'Ti', 'Pi', 'Ei', 'Zi', 'Yi', 'Bi'])


class ConvertDataSize():
	'''
	Convert data size. Given a user input size like
	"80%+10G -1M" = 80% of the blocksize + 10 gigabytes - 1 Megabyte
	'''

	def __init__(self, blocksize=1e9, binary_prefix=1000, rounding=0):
		self.blocksize = blocksize					# Device blocksize for multiplying by a percentage
		self.binary_prefix = binary_prefix			# 1000 or 1024 byte kilobytes
		self.rounding = rounding					# Round to sector sizes

	def _process(self, arg):
		arg = arg.strip().upper().replace('B', '')
		if not arg:
			return 0

		start = arg[0]
		end = arg[-1]

		if start == '-':
			return self.blocksize - self._process(arg[1:])

		if '+' in arg:
			return sum(map(self._process, arg.split('+')))

		if '-' in arg:
			args = arg.split('-')
			val = self._process(args.pop(0))
			for a in args:
				val -= self._process(a)
				return val

		if end in 'KMGTPEZY':
			return self._process(arg[:-1]) * self.binary_prefix ** (' KMGTPEZY'.index(end))

		if end == '%':
			if arg.count('%') > 1:
				raise ValueError("Extra % in arg:", arg)		# pylint: disable=W0715
			arg = float(arg[:-1])
			if not 0 <= arg <= 100:
				print("Percentages must be between 0 and 100, not", str(arg) + '%')
				return None
			else:
				return int(arg / 100 * self.blocksize)

		if is_num(arg):
			return float(arg)
		else:
			print("Could not understand arg:", arg)
			return None

	def __call__(self, arg):
		"Pass string to convert"
		val = self._process(arg)
		if val is None:
			return None
		val = int(val)
		if self.rounding:
			return val // self.rounding * self.rounding
		else:
			return val


def sort_dict(dic, reverse=False):
	'''Return a sorted version of a dictionary
	return sorted([(k,v) for k,v in dic.items()], key=lambda x: x[index], reverse=reverse)'''
	return {key: dic[key] for key in sorted(dic.keys(), reverse=reverse)}


def strip_punct(text):
	'''Strip punctuation from a string'''
	punct = '\'!"#$%&\\\'()*+,-./:;<=>?@[\\\\]^_`{|}~\''	# repr(string.punctuation)
	return text.translate(str.maketrans('', '', punct))


def sig(num, digits=3):
	"Return number formatted for significant digits"
	if num == 0:
		return '0'
	negative = '-' if num < 0 else ''
	num = abs(float(num))
	power = math.log(num, 10)
	if num < 1:
		num = int(10**(-int(power) + digits) * num)
		return negative + '0.' + '0' * -int(power) + str(int(num)).rstrip('0')
	elif power < digits - 1:
		return negative + ('{0:.' + str(digits) + 'g}').format(num)
	else:
		return negative + str(int(num))


def rfs(num, mult=1000, digits=3, order=' KMGTPEZYB', suffix='B', space=' '):
	'''A "readable" file size
	mult is the value of a kilobyte in the filesystem. (1000 or 1024)
	order is the name of each level
	suffix is a trailing character (B for Bytes)
	space is the space between '3.14 M' for 3.14 Megabytes
	'''
	if abs(num) < mult:
		return sig(num) + suffix

	# https://cmte.ieee.org/futuredirections/2020/12/01/what-about-brontobytes/
	bb = mult**9
	if bb <= num < 2 * bb:
		print("Fun Fact: The DNA of all the cells of 100 Brontosauruses " + \
		      "combined contains around a BrontoByte of data storage")
	if num >= bb:
		# Comment this out when BrontoBytes become mainstream
		order = list(order)
		order[9] = 'BrontoBytes'
		suffix = ''

	# Faster than using math.log:
	for x in range(len(order) - 1, -1, -1):
		magnitude = mult**x
		if abs(num) >= magnitude:
			return sig(num / magnitude, digits) + space + (order[x] + suffix).rstrip()
	return str(num) + suffix		#Never called, but needed for pylint


class Eprinter:
	'''Drop in replace to print errors if verbose level higher than setup level
	To replace every print statement type: from common import eprint as print

	eprint(v=-1)    # Normally hidden messages
	eprint(v=0)     # Default level
	eprint(v=1)     # Priority messages
	eprint(v=2)     # Warnings
	eprint(v=3)     # Errors
	'''

	# Setup: eprint = Eprinter(<verbosity level>).eprint
	# Simple setup: from common import eprint
	# Usage: eprint(messages, v=1)

	# Don't forget they must end in 'm'
	BOLD = '\033[1m'
	WARNING = '\x1b[1;33;40m'
	FAIL = '\x1b[0;31;40m'
	END = '\x1b[0m'

	def __init__(self, verbose=0):
		self.level = verbose
		self.history = []

		#If string starts with '\n', look at history to make sure previous newlines don't exist
		self.autonewlines = True

	def newlines(self, num=1):
		"Print the required number of newlines after checking history to make sure they exist."
		lines = sum([1 for line in self.history[-num:] if not line.strip()])
		num -= lines
		if num:
			print('\n' * (num), end='')
		return num


	def eprint(self, *args, v=0, color=None, header=None, **kargs):
		'''Print to stderr
		Custom color example: color='1;33;40'
		More colors: https://stackoverflow.com/a/21786287/11343425
		'''
		verbose = v
		# Will print if verbose >= level
		if verbose < self.level:
			return 0

		if not color:
			if v == 2 and not color:
				color = f"{self.WARNING}"
			if v >= 3 and not color:
				color = f"{self.FAIL}" + f"{self.BOLD}"
		else:
			color = '\x1b[' + color + 'm'

		msg = ' '.join(map(str, args))
		if self.autonewlines:
			match = re.match('^\n*', msg)
			if match:
				num = self.newlines(match.span()[1])
				if num:
					#print('created', num, 'newlines', repr(msg[:64]))
					msg = msg.lstrip('\n')


		self.history += msg.splitlines()
		if len(self.history) > 64:
			self.history = self.history[64:]

		if header:
			msg = header + ' ' + msg
		if color:
			print(color + msg + f"{self.END}", file=sys.stderr, **kargs)
		else:
			print(msg, file=sys.stderr, **kargs)
		return len(msg)


def warn(*args, header="\n\nWarning:", sep=' ', delay=1 / 64):
	msg = undent(sep.join(list(map(str, args))))
	time.sleep(eprint(msg, header=header, v=2) * delay)


def round_down(num, mod=1):
	"Round a number down to the next modulus"
	if not num % mod:
		return num
	return num // mod * mod


def round_up(num, mod=1):
	"Round a number up to the next modulus"
	if not num % mod:
		return num
	return num // mod * mod + mod


def bisect_small(lis, num):
	'''Given a sorted list, returns the index of the biggest number smaller than num
	Unlike bisect will never return an index which doesn't exist'''
	end = len(lis) - 1
	for x in range(end + 1):
		if lis[x] > num:
			return max(x - 1, 0)
	else:
		return end


def get_blocksize(devname):
	"Get size of block device. Requires Root"
	f = os.open(devname, os.O_RDONLY)
	size = os.lseek(f, 0, os.SEEK_END)
	os.close(f)
	return size


def tabber(text, tab=' '*4):
	"Insert whitespace at the beginning of every newline"
	return '\n'.join([tab+line for line in text.split('\n')])


def undent(text, tab=''):
	"Remove whitespace at the beginning of lines of text"
	return '\n'.join([tab + line.lstrip() for line in text.splitlines()])


def uerror(*args, header='\nError: ', sep=' ', quit=True, **kargs):
	"Friendlier version of error without the red text and python debugging"
	msg = undent(sep.join(args))
	if '\n' in msg and header:
		msg = header + '\n' + tabber(msg, tab=' ' * (len(header.strip())+ 1))
	else:
		msg = header +  msg
	print(msg, **kargs)
	if quit:
		sys.exit(1)


def is_num(num):
	"Is the string a number?"
	if str(num).strip().replace('.', '', 1).replace('e', '', 1).isdigit():
		return True
	return False


eprint = Eprinter(verbose=1).eprint     # pylint: disable=C0103

'''
&&&&%%%%%&@@@@&&&%%%%##%%%#%%&@@&&&&%%%%%%/%&&%%%%%%%%%%%&&&%%%%%&&&@@@@&%%%%%%%
%%%%%%%%&@&(((((#%%&%%%%%%%%%&@@&&&&&&%%%&&&&&%%%%%%%%%%%&&&&%&%#((((/#@@%%%%%%%
&&%%%%%%&@(*,,,,,,,/%&%%%%%%%&@@&&&&&%%&&&&%%&&%%%%%%%%%%&&&%#*,,,,,,*/&@&%%%%%%
%%%%%%%&@&/*,,,*,*,,*/%&%%%%%&@@&&&&&&%%&&&&&&&%%%%%%&%%%&&%*,,,,,,,,**#@&&%%%%%
&&&&&%%&@#(**********,*(#&%%%&@&&&&%%%%%%%%%&&&%%%%%%&%&&#*****,*******#@&&%%%%%
&&&%%%&&#/***/*****/*,**,*%&%&@@&&&&&&&&&&&&&&&%%%%%%&&#*,,,*/******/***(%&%%%%%
&&&%%%&%/*****///////**,,,,*/%%&&@@@@@@@@@@@@@@@@&&%#*,,,*,*(///////*****#%&%%%%
@@&%%#&#/,,,*/(//((((//**,,*/#&@@@@@&&&&&&&&&&@@@@@%(/*,,**/(/(((/(//*,,*(&&%%%%
&&&%##&#*,,,*////((((/*///(&@&@@&&&#%((//(/###%&@&@@@@#//**//(#(///***,.,/&&%%%%
%%%%%#%#*,,,**////(///((#&&&%@&%%(/*,,......,,/(#%&&&@@@%((/(/#(///**,,,,(&%%%%%
&&%%%#%%/,..***//(#(#%%&@@@&@%(*.,,..       ...,.,/#@&@@@&&%#(((///**,..,#%%%%%%
%&%%%%%#*,****/(##&@@@&@@@@&%*,....           ....,,(&@@@@@@&@&%((//****,(%%%%%%
%&%%%%%#/,**/#&@@@&@@@@@@@&(*,......    .     ..,..,.(&@@@@@@@&@@@&%#**,*(%%%%%%
&&%%%%#&#(#&@@@&@@@@@@@@%((#@@%&&((,,,,,..,,(**(%@@&@%##(&@@@@@@@@&&@@%#(%%%%%%%
&&&%%%%%&&&&&&@@@@@@%###%@(,%&/@@&(%(/*,..,*/%##&&,%@(*&@#((%&@@@@@@&&@&%%%%&&%%
&&%%%%%%&&&@@@@@@@@#((*#@%,#%%&@#%(/**//,****/(#%%%&&%*(@@*/#(&@@@@@@@&&%%%%%%%%
&&&%%%%%&@@@@&%#/,,,,*,(/%&@@&((%(*,*,,*,**,,*,*#%(#@@&%((**,,,,*#(%&@@&&%%%%%%%
&&&%%%%%@@@@%*/*,...,*,,/*#(//#****,***********,**/#/##(/*,*,...,*/*/&@@&%%&%%%%
&&%%%%%%&@@@(//,....,,*/****/,,/**************/***/,,//**/**,....,*//&@@&%%&%%%%
&&&%%%%%&@@%(/*,. ...,****/*/(//*%&@@&%%%%%%&&&&//*/(*/**/**......,/*#&@&%&&&&%%
&&%%%%%%&@@%(**,,....,/**/((/,#&&&&&%#((((((%&&&@&%/*/(/**/*,. ..,,*/((#@&&&&&&%
%&%%%%%%&&#(/**,..,,,***/((,./%&%&&&@&(/#((#@@&&&%&%,,/((*,/*,,..,,,///(%&%&&&&&
&&%%%%%%&#,**,.,..,,*(//(/,,.,&&&@#&@@##%(#&@&%%@&&#.,,/(((//*,,..,,**,*&%&&%&&&
&&%##%%%#/**,,,,..,*/((((*...,,#&##%(#%%&%%###%(%&/,.. **((((/,...,,,,**(%%#%%%&
&&%####(**,,,.,,.,,/(/(//*,,..../%&(##%&&&%%(#%&#, .. .**//(/(*,,..,.,,**/((#%%%
&&&%#///*,........,/(((//**,.   ,,(#%%%%%%&#%##**.   ,,*//((((*,........,*//(%%%
%%%%(/**...       .,/(((///*., .,*(#(%%%%%%%%##/*,..,,*///((/*.      .....**/(%%
%%%%#(,..          .,/((/(//****,/(((###%#%(#///**,,**/((/((*,          .,.,(%%%
&&%%%#/*...          ,*/(/(/((%%&#&#(/%./.*%(#%#%#&&(((/(/*,.          ..,**(&%%
&&%%%%(*.....          ..*((/**(#&&&&&&&%%%&%&&&%(/,*/((*..           .,..*(&&%%
&&%%%%&#*.      .        */(#/*,,*/((%#%%%%%((**,.*/(#(/,       .       ,(%&%%&%
%%%%%%&%#//**,..           .**(((*,...,,**,,..*,/((/*,.          ...,,//(#%%%%%%
%%%&&&%(/*,**,..,,.,..       .,,**//**,*,,,*,////*,,.        .,.,...,,,**//#%&%%
%%%&&%#/*,*,.    ...      ..         ...  ,.. .       .       ...   ..,,*/(#%&%%
&&&&&%(((*.*... . .*,.   .           .*%%#(,.          .    .*,. ..,.,,**/(%#&%%

Generated by https://github.com/SurpriseDog/Star-Wrangler
a Python tool for picking only the required code from source files
written by SurpriseDog at: https://github.com/SurpriseDog
2021-09-16
'''
